\subsection[Grenzen der Diagonalisierung]{Grenzen der Diagonalisierung}
\begin{frame}
	\frametitle{Grenzen der Diagonalisierung}
	\framesubtitle{Wiederholung Diagonalisierung}
	\begin{KITinfoblock}{Was ist Diagonalisierung} {
			Als Diagonalisierung wird (hier) ein Beweis bezeichnet, der nur auf den beiden folgenden
			Eigenschaften von TM aufbaut.
			
			\begin{enumerate}
				\item<2-> Die Existenz einer Repräsentation von TM durch Zeichenketten (Gödelnummer)
				\item<3-> Die Fähigkeit eine andere TM mit geringem zusätzlichen Zeit- oder Platzbedarf zu simulieren (Universelle TM)
			\end{enumerate}		
		}
	\end{KITinfoblock}
\end{frame}

\begin{frame}
	\frametitle{Grenzen der Diagonalisierung}
	\framesubtitle{Definition von Orakelmschinen}
	\begin{KITinfoblock}{Definiton Orakel-Turingmaschine} {
			Eine Orakel-Turingmaschine $M$ ist eine TM, die folgende zusätzliche Eigenschaften hat:
			\begin{itemize}
				\item<2-> ein spezielles zusätzliches Band (Orakelband) und 3 spezielle zusätzliche Zustände $q_{query}, q_{yes}, q_{no}$.
				\item <3-> ein Orakel $O \subset \{0,1\}^*$
				\item <4-> Wenn $M$ den Zustand $q_{query}$ betritt, ist der Folgezustand
					\begin{itemize}
					\item $q_{yes}$, wenn für Inhalt $s$ des Orakelbands gilt $s \in O$ und
				    \item	$q_{no}$, wenn  $s \notin O$ 
					\end{itemize} 
				\item<5-> Das Orakel liefert die Antwort in einem Berechnungsschritt
			\end{itemize}
		}
	\end{KITinfoblock}
\end{frame}
\begin{frame}
	\frametitle{Grenzen der Diagonalisierung}
	\framesubtitle{Satz von Baker-Gill-Solovay}
	\begin{KITinfoblock}{Baker,Gill,Solovay, 75}
		Es existieren Orakel A, B so dass ${\P}^A = {\NP}^A$ und ${\P}^B \neq {\NP}^B$
	\end{KITinfoblock}
	\pause
	\begin{overprint}
		\begin{itemize}[<+->]
		\item Ein Beweis der Diagonalisierung verwendet gilt auch für TM mit Orakel!
		\item $\Rightarrow$ ein Beweis für die P-NP Frage kann keine Diagonalisierung
		verwenden!
		\end{itemize}
	\end{overprint}
\end{frame}

\begin{frame}
	\frametitle{Grenzen der Diagonalisierung}
	\framesubtitle{Beweis : ${\P}^A = {\NP}^A$ }
	\begin{itemize}[<+->]
	
	\item ${\P}^A = {\NP}^A$ haben wir gerade schon gesehen:
			Nutze einfach das Orakel A = $\mathbf{EXPCOM}$
	\item B zu konstruieren ist schwieriger (und interessanter!)
	\end{itemize}	
\end{frame}

\begin{frame}{Beweis : ${\P}^B \neq {\NP}^B$}
	\begin{Definition}
		Für eine Sprache B sei $U_B = \lbrace 1^n :$ Es gibt einen String
		der L\"ange n in B $\rbrace $
	\end{Definition}	
	\pause
	
	\begin{itemize}[<+->]
		\item Wir sehen sofort ein : $U_B \in {\NP}^B$ , da eine nicht det. TM
			ein Zertifikat raten kann.
		\item M\"ussen also nur noch B so konstruieren, dass $U_B \notin {\P}^B$
	\end{itemize}
\end{frame}

\begin{frame}{Konstruktion von B}
	Wir konstruieren eine Folge von Sprachen $(B_i)_{i \in \mathbb{N}}$ so , dass 
	$B = \lim_{n \to \infty} B_i$	
	\begin{itemize}[<+->]
		\item Wie stellen wir sicher, dass alle Turing Maschinen $U_B$ nicht
			in polynomieller Zeit entscheiden können?
		\item Tipp: Die Menge aller Turing Maschinen ist abzählbar
	\end{itemize}
\end{frame}

\begin{frame}{Konstruktion von B}
	\begin{itemize}[<+->]
	\item Genau : iterieren über alle Turing Maschinen $M_i$ und stellen sicher, dass
		$M_i$ nicht in polynomieller Zeit $U_B$ entscheiden kann
	\item Nutze dabei, dass die Anzahl der Wörter exponentiell in der Eingabelänge wächst
	\end{itemize}
\end{frame}

\begin{frame}{Konstruktion von $B_i$}
	Wir fangen an mit $B_0 = \emptyset$. Konstruktion f\"r $B_i$ :
	\begin{itemize}
		\item Wähle n so , dass n größer als alle Strings in $B_{i-1}$
		\item Lasse $M_i$ auf Eingabe $1^n$ genau $2^n / 10$ Schritte laufen
	\end{itemize}
\end{frame}